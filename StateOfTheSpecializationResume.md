# State of the Specialization
Resume of the [State of the Specialization](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html) written by Brian Goetz.

## Goal 
Support generics over primitives (and eventually value types). By adopting a _gradual migration compatibility_, so old implementations won't break if referencing generic classes, now using primitives and specialized.
To do so, a hybrid homogeneous-heteregeneous translation is used.
The main advantage is to avoid boxing issues, when using huge collections of primitive values.

## Vocabulary (restricted to this document)
- **Homogeneous translation** : Using erasured implementation to produce one class for all reference instantiations (not supporting primitive instantiations because of starred **a** bytecode).
- **Heteregeneous translation** : Creation of different instantiations of a parametric type in the source language corresponding to different runtime classes.
- **Specialization** : For each primitive type declared by the JAVA specification, production from an erased class file a specialized version manipulating this primitive type.
- **Erasure** : //TODO
- **Explicit type for a class or method** : Type variables declared with a class or method.
- **Implicit type variable** : Any type variables associated with an enclosing generic class or method.
- **avars** : **any** type variables.


## Existing problems
### Common ancestor
Primitive and reference values have no common ancestor. Rather than simply changing the rules for generics in the language and reinterpreting existing source files, a class should opt into "enhanced generic" treatment by considering a new type variable modifier **any**.
Example :
```java
class Box<any T> {
    private final T t;
    public Box(T t) { this.t = t; }
    public T get() { return t; }
}
```
#### Why not T extends Any
If any is chosen as a bound, users will then try to declare variables of type Any and will be disapointed. This is not 

### Current generated bytecode state
The compilation of a class using a generic type variable T, will implie its erasure into its highest bound (which is visible in signatures of the class). Object is the most general type available, the bytecode generated will only manipulate references, but will not provide any informations on generic instantiations. Hence opcode produced will only considere references, and will not suit for the manipulation of primitive values.
The existing JVM bytecode has no type that can hold either a reference type or a primitive type.

### Hybrid solution
For **List<String>** and **List<Integer>** both will be represented by the same runtime class List.class as before. But **List<int>** and all instantiation of a primitive type will have their own representation.

### Subtyping consequences
Let's considere the class Box :
```java
  class Box<T> {
    private final T t;
    public Box(T t) { this.t = t; }
    public T get() { return t; }
}
```
We have the following inheritance scheme :
```java
  Box<Integer>  <:  Box<?>
  Box<?>  <:  Box   
  // Box is a raw type
  // By transitivity
  Box<Integer>  <:  Box
```
**Box<int>** can not be a subtype of Box, otherwise it would inherit of a field t of type **Object**. Whereas **t** should be of type **int**.
From this, we can determine invalid inheritances :
```java
ArrayList<int>  <:  ArrayList<Integer>
ArrayList<int>  <:  ArrayList<?>
ArrayList<int>  <:  ArrayList
List<int>  <:  List<Integer>
List<int>  <:  List<?>
List<int>  <:  List
```
We do have :
```java
ArrayList<int>  <:  List<int>
```
Moreover, there is plenty of code assuming that **Box<?>** really means **Box<? extends Object>**.

## Representation of the hybrid translation
Multiple approach allow the hybrid translation. The one used consist in producing a classfile with additional metadata that allows the classfile to be both used directly as an erased classfile and as a template for specialization.

## Specialization
To perform specialization for a type **T** into for example **T=int**, a ***T** next to a type name or bytecode will mean that the type in the classfile is derived from the erasure of **T**, and therefore would need to be adjusted during specialization.
Instances of **Object*T** would be replaced with int and replace starred **a** bytecodes with corresponding **i** ones.
To do it practialy at runtime, the specialization should be entirely mechanical, without any addition of dataflow analysis or typechecking beyond existing verification.

## Classloading
Nominal classes using convention such as **Box${T=int}** are unsatisfying as a solution for specialization because it requires the imposition of semantics assumptions based on the structure of a class name. It is only fine for exposition.

## Multiple type variables
For a single type variable, when we specialize a class, we also specialize its supertypes when they refer to the subclasses type variable.


## Compromise conclusions
1. A class should opt into "enhanced generic" treatment, rather than simply changing the rules for generics in the language.
2. A hybrid homogeneous-hetergeneous translation is needed, where reference instantiations can continue to use the erased homogeneous translation (and therefore remain compatible with existing code), whereas value instantiations will require a heterogeneous translation.
3. For compatibility reasons we may be forced into the interpretation of **Box<?>** meaning **Box<? extends Object>**.

# Implementation details
Efficient specialization of a class requires to not access to the bytecode of any class other than the considered one. To do so, the compiler adds several new bytecode attributes :
1. TypeBariablesMap
2. BytecodeMapping
They will allow to capture the information that would otherwise be erased or placed in other classfiles.

## TypeVariableMap attribute
It is a catalog of all type variables in scope for a class, method, or field (including those of lexically enclosing generic classes or methods).
For each type variable : It identifies :
* Where it is defined
* Whether it is an **any** type variable
* Its erasure

We consider the following class :
```java
class Outer<any T> {
    class Inner<any U> {
        <any V> void method() {
            class Local<any W> {
                void munge(T t, U u, V v, W w) {  }
            }
        }
    }
}
```

Will generate :
```java
TypeVariablesMap:
  LOuter$Inner$1Local;:
    Tvar  Flags  Erased bound
    W     [ANY]  Ljava/lang/Object;
  LOuter$Inner;::method()V:
    Tvar  Flags  Erased bound
    V     [ANY]  Ljava/lang/Object;
  LOuter$Inner;:
    Tvar  Flags  Erased bound
    U     [ANY]  Ljava/lang/Object;
  LOuter;:
    Tvar  Flags  Erased bound
    T     [ANY]  Ljava/lang/Object;
```

## BytecodeMapping attribute
For any method that contains bytecodes that might need to be specialized, the compiler generates a BytecodeMapping attribute which contains mappings from bytecode indexes to additional pre-erasure signature information describing the types being manipulated by that specific bytecode.
**note** : A more robust means of associating metadata with bytecodes that can survive common bytecode manipulations intact would be desirable (for example after a classfile transformation with any tool).


opcode         | category  | UTF-8 Value
---------------|-----------|-------------
aloadXX        | 1         |local variable type
astoreXX       | 1         |top-of-static element type
aaload         | 1         |array element type
aastore        | 1         |array element type
areturn        | 1         |enclosing method return type
dupXX          | 1         |top-of-stack element type
if_acmpXX      | 1         |top-of-stack element type
new            | 2         |class type
anewarray      | 2         |array type
amultinewarray | 2         |array type
ldc            | 2         |class literal type
checkcast      | 2         |cast type
instanceof     | 2         |instanceof type
XXfield        | 3         |instantiated field descriptor
invokeXX       | 3         |instantiated method descriptor

3 categories : 

1. **Data-movement operations**. Here, it is stored the *unerased type of the data being moved by this opcode*, and such opcodes are specialized if and only if the associated unerased type is the instantiation of an **any** type variable or an array thereof. For example, the **areturn** method in the **get()** method of **Box** is moving a variable of type **T**, and so should be specialized.
2. **Class-oriented operations**. Here, it is stored the *unerased instantiated type of the generic class being described by this operation*, and such are specialized if and only if at least one type parameter is an instantiation of an any type variable or array thereof. For example, a new operation that instantiates a Box<int> describes a specialization of Box<T>, and so should be specialized.
3. **Member-oriented operations**. Here, the opcode has two signatures to *keep track of; the instantiated type of the receiver, and the instantiated type of the member signature*. These operations are specialized if the receiver (**this**), or of the signature has one or more type parmeters that are instantiations of any type variables. For example, the fetch from t in the get() method of Box must be specialized both for the type of the field and for the owning class.

Result :
```java
class Box<T extends java.lang.Object> extends java.lang.Object
{
  public Box(T);
    descriptor: (Ljava/lang/Object;)V
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: aload_1
         6: putfield      #2                  // Field t:Ljava/lang/Object;
         9: return
    BytecodeMapping:
      Code_idx  Signature
          5:    TT;
          6:    LBox<TT;>;::TT;
    Signature: #15                          // (TT;)V

  public T get();
    descriptor: ()Ljava/lang/Object;
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field t:Ljava/lang/Object;
         4: areturn
    BytecodeMapping:
      Code_idx  Signature
          1:    LBox<TT;>;::TT;
          4:    TT;
    Signature: #18                          // ()TT;
}
Signature: #19                          // <T:Ljava/lang/Object;>Ljava/lang/Object;
```

## Language restrictions
* Cannot convert null to a variable whose type is T
* Cannot compare T to null
* Cannot convert T to Object
* Cannot convert T[] to Object[]
* Cannot synchronize using an expression of type T as a lock
* Cannot convert from Foo<T> to Foo<?> or Foo
* No unbounded wildcards Foo<?>

## Language enhancements
Possible on avars not possible on erased type variables or instantiations of erased generic types :

* You can instantiate an array of **T** with new **T[size]**. The behavior of this is to instantiate an **Object[]** when **T** is instantiated with a reference type and the correct value array when **T** is specialized to a value type.
* Use of specialized classes (e.g., **ArrayList<int>**) wherever a reference type is allowed, such as in superclass definitions, member signatures, instanceof tests, casts.
* Class literals for specialized types: **ArrayList<int>.class**.


# Specializer transformations list
* The class name is mangled to reflect specializations
* Constructors are renamed to the mangled class name
* Type variable substitution (for any instantiated avars) is performed on the superclass and interfaces, and the resulting names mangled
* Static fields and methods are stripped (see section Statics)
* Type variable substitution and name mangling is performed on the types of all fields
* Type variable substitution and name mangling is performed on the signatures of all methods
* Methods that are not applicable to the current instantiation parameters are stripped (see "Layers", below)
* If any type variable substitutions are long or double, local variable numbers for all bytecodes in the method are adjusted to reflect that these consume two local variable slots, not one
* For category-1 bytecodes, type variable substitution is performed on the contents of the corresponding **BytecodeMapping** attribute entry, and, if any substitutions are needed, the opcode is adjusted to the appropriate primitive-typed opcode. DUP and similar are adjusted to DUP2 and similar if they are moving a long or double value. IF\_ACMPxx bytecodes are to either IF_ICMPxx if moving int or shorter integral values, or an xCMP followed by IFEQ for long, double, or float values.
For category-2 bytecodes, type variable substitution is performed on the contents of the corresponding **BytecodeMapping** attribute entry, and, if any substitutions are needed, the name is mangled and the mangled name used instead.
* For category-3 bytecodes, the corresponding **BytecodeMapping** attribute is split into a receiver part and a descriptor part; the bytecode owner component is adjusted based on the receiver part, and the bytecode descriptor component is adjusted based on the descriptor part. For **invokedynamic** instructions whose bootstrap semantics are associated with specialization (see Generic Methods, below), additional specialization-specific transforms are performed on the bootstrap arguments, such as type substitution and name mangling.


# Statics
???? Ask to Rémi

# Generic methods
Harder to specialize than classes, because vm implementations are ofter organized around the assumption that the set of methods in a class is fixed.
The approach chosen is to use **invokedynamic** to invoke generic methods that might be specialized. It is provided a bootstrap (**GenericMethodSpecializer**) whose static argument list includes the requested specilializations.
Challening corner case : When method bodies rely on instance context, such as "super" calls in generic methods.)

# Migration challenges
Librairies such as Collections (that is most wished to be "any-fied") exhibit many patterns where it is implicitly assume that type variables are reference-only.

## Assumptions of reference-ness
```java
T[] array = (T[]) new Object[n];
```
Would be transformed into :
```java
T[] array = new T[n];
```
More generally, there are other implementation idioms that rely on the assumption that T < : Object; these will either need to be adjusted to use compatible idioms, or restricted to erased generics.

## Reference-primitive overloadings
These methods would have a problem if specialied with **T=int** :
```java
public void remove(int position);
public void remove(T element);
```
Such overloads would be problematic both on the specialization side (what methods to generate) and on the overload selection side (which method to invoke.)

## Incomplete generification
Classes like **Collection** also have methods incompletely generified.
For example **remove(Object)**. For a specialized instantiation, it should be specialized as if the method was **remove(T)**. Similarly, some methods use wildcard-instantiated types in their signatures like **Collection.removeAll** takes a **Collection<?>** as an argument, rather than **Collection<? extends T>**.

## Null
A consequence of the assumption that T < : Object is that T-valued variables can be assigned null or compared to null. And we can no take into account the option to treat assignment to null as an assignment to the zero value.
TODO

# Manual control over specialization
Because some possible features could affect the specialization process, it could be fine to substitute hand-written code for the mechanically specialized code.

## Implementation by parts
**Optional** can use a single field for its representation for references, but requires two fields for a value implementation (a separate "present" bit).
Ask Rémi for the first part.

## Overriding specific instantiations of specialized classes
**ArrayList<boolean>** one might want to use a packed bitfield representation instead.

## Specializing the specializations
We could use automated specialization to inject new or override existing instantiation-specific method implementations. (For example, a **List** class might want a **sum()** method when instantiated with a numeric type.)

## Overriding specific instantiations of generic methods
Same issues as classes for generic method.

# The "Peeling" Technique
To handle these migration challenges listed above, (they show up in the core Collection classes), a possible way out is via _peeling_ a generic class into a generic layer and one or more layers corresponding to "all erased reference instantiations", "all value instantiations", or specific type instantiations. This technique has the potential to address many of the migration challenges that have been posed so far.

Consider the overload pair in a List-like class:
```java
interface ListLike<T> {
    public void remove(int position);
    public void remove(T element);
}
```
These method are required for reference instantiations. But nothing for non-reference instantiations since none currently exist.

Idea :  Considere ListLike as an union of a type that is generic across all instantiations, and a type that is generic across only reference instantations.

If we were writing this class from scratch in a post-specialization world, we might have written it as:
```java
interface ListLike<any T> {
    void removeByIndex(int position);
    void removeByValue(T element);
}
```
But ithis is not possible for compatibility issues. (source-compatibility or binary-compatibility).
Peeling allows to add these methods to the generic layer, and implement them in a reference-specific layer, without requiring them in the specializations, restoring compatibility :
```java
interface ListLike<any T> {
    // New methods added to the generic layer
    void removeByValue(T element);
    void removeByIndex(int pos);

    layer<ref T> {
        // Abstract methods that exist only in the ref layer
        void remove(int pos);
        void remove(T element);

        // Default implementations of the new generic methods
        default void removeByIndex(int pos) { remove(pos); }
        default void removeByValue(T t) { remove(t); }
    }
}
```
Existing implementations of ListLike would continue to compile since the new methods have a default implementation for reference specializations.
This technique also enables the "implementation by parts" technique; it is possible to declare a method abstract in the generic layer and provide concrete implementations in both the value and reference layers. If we allowed layers for T=int, it would also enable the "specializing the specializations" technique.
This technique also enables the "implementation by parts" technique; it is possible to declare a method abstract in the generic layer and provide concrete implementations in both the value and reference layers. If we allowed layers for T=int, it would also enable the "specializing the specializations" technique.

# Further investigation
Goal is to any-fying core JDK libraries, specifically Collections and Streams and experimenting.
Streams library is a particular candidate for specialization since it already contians manually specialized types for primitive streams.
A successful conversion would be to end up with **IntStream extends Stream<int>** and be able to jettison (Ask) the large amount of hand-specialized code that the streams library contains.

While "peeling" technique is promising, errors will occur in details.
Focus : 
* addresse the known challenges.
* scale to multiple type parameters without excessive additional complexity.
* intuitive to developers.


